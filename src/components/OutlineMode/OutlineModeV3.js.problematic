import React, { useState, useEffect, useRef, useMemo } from 'react';
import { generateRowId, generateSectionId } from '../../models/SectionModel';
import '../../styles/outlinev3.css';

/**
 * OutlineModeV3 - A complete port of the original App.js highly refined outline mode
 * adapted to work with the section-based data model
 */
const OutlineModeV3 = ({
  sectionData,
  onDataChange,
  includeIds = true,
  includeHeaders = true,
  includeSections = true,
  onPendingDeleteChange,
  // Keyboard navigation props from parent
  inputRefs: parentInputRefs,
  handleKeyDown: parentHandleKeyDown,
  focusInput: parentFocusInput,
  editingCell: parentEditingCell,
  setEditingCell: parentSetEditingCell,
  focusedCell: parentFocusedCell,
  setFocusedCell: parentSetFocusedCell,
  pendingDeleteRow: parentPendingDeleteRow,
  pendingDeleteCol: parentPendingDeleteCol,
  setPendingDeleteRow: parentSetPendingDeleteRow, 
  setPendingDeleteCol: parentSetPendingDeleteCol,
  pendingDeleteTimer: parentPendingDeleteTimer,
  pendingDeleteColTimer: parentPendingDeleteColTimer,
  // Quickfill props
  quickfillState: parentQuickfillState,
  setQuickfillState: parentSetQuickfillState,
  handleQuickfillKeyDown: parentHandleQuickfillKeyDown,
  openQuickfill: parentOpenQuickfill,
  closeQuickfill: parentCloseQuickfill,
  getQuickfillOptions: parentGetQuickfillOptions
}) => {
  // Track focused cell for highlighting
  const [focusedCell, setFocusedCell] = useState({ sectionIdx: null, rowIdx: null, colIdx: null });
  
  // Track editing cell
  const [editingCell, setEditingCell] = useState(null); // format: "sectionIdx-rowIdx-colIdx-field"
  
  // Track name field focus for animation/display
  const [focusedNameField, setFocusedNameField] = useState(null); // format: "sectionIdx-rowIdx-colIdx"
  
  // Track pending deletions
  const [pendingDeleteRow, setPendingDeleteRow] = useState(null); // format: "sectionIdx-rowIdx"
  const pendingDeleteTimer = useRef(null);
  
  const [pendingDeleteCol, setPendingDeleteCol] = useState(null);
  const pendingDeleteColTimer = useRef(null);
  
  // State to highlight all positions at same depth during column delete
  const [highlightSamePosition, setHighlightSamePosition] = useState(false);
  
  // References to input elements
  // Create local inputRefs ref
  const localInputRefs = useRef({});
  
  // Use parent's inputRefs if provided, otherwise use local
  const inputRefs = parentInputRefs || localInputRefs;
  
  // References to list items for drag and drop
  const liRefs = useRef({});
  
  // Drag and drop state
  const [draggingIndex, setDraggingIndex] = useState(null);
  const [dragOverIndex, setDragOverIndex] = useState(null);
  const [insertionLineTop, setInsertionLineTop] = useState(null);

  // --- Quickfill dropdown state and logic ---
  const [quickfillState, setQuickfillState] = useState({
    sectionIdx: null,
    rowIdx: null,
    colIdx: null,
    open: false,
    selectedIndex: 0,
    field: 'value' // 'value' or 'name'
  });

  // Helper: known sets and aliases for quickfill sorting
  const quickfillKnownSets = [
    {
      name: 'Severity',
      set: ['Critical', 'High', 'Medium', 'Low'],
      aliases: { 'Urgent': 'Critical', 'Blocker': 'Critical', 'Major': 'High', 'Minor': 'Low' },
      aliasesForColumn: ['Urgent', 'Blocker', 'Major', 'Minor']
    },
    {
      name: 'Priority',
      set: ['High', 'Medium', 'Low'],
      aliases: { 'Urgent': 'High', 'Critical': 'High', 'Blocker': 'High', 'Normal': 'Medium', 'Minor': 'Low' },
      aliasesForColumn: ['Urgent', 'Critical', 'Blocker', 'Normal', 'Minor']
    },
    {
      name: 'Status',
      set: ['To Do', 'In Progress', 'Done'],
      aliases: { 'Open': 'To Do', 'Complete': 'Done', 'Completed': 'Done', 'Started': 'In Progress', 'Closed': 'Done', 'Finished': 'Done' },
      aliasesForColumn: ['Open', 'Complete', 'Completed', 'Started', 'Closed', 'Finished']
    },
    {
      name: 'Resolution',
      set: ['Open', 'Pending', 'Resolved', 'Closed'],
      aliases: { 'In Progress': 'Pending', 'Done': 'Resolved', 'Complete': 'Resolved', 'Completed': 'Resolved' },
      aliasesForColumn: ['In Progress', 'Done', 'Complete', 'Completed']
    },
    {
      name: 'Yes/No',
      set: ['Yes', 'No'],
      aliases: { 'True': 'Yes', 'False': 'No', 'Y': 'Yes', 'N': 'No' },
      aliasesForColumn: ['True', 'False', 'Y', 'N']
    },
    {
      name: 'Enabled/Disabled',
      set: ['Enabled', 'Disabled'],
      aliases: { 'On': 'Enabled', 'Off': 'Disabled', 'Active': 'Enabled', 'Inactive': 'Disabled' },
      aliasesForColumn: ['On', 'Off', 'Active', 'Inactive']
    },
    {
      name: 'Size',
      set: ['XS', 'S', 'M', 'L', 'XL'],
      aliases: { 'Extra Small': 'XS', 'Small': 'S', 'Medium': 'M', 'Large': 'L', 'Extra Large': 'XL' },
      aliasesForColumn: ['Extra Small', 'Small', 'Medium', 'Large', 'Extra Large']
    }
  ];

  // Helper to normalize a value to a known set (if alias exists)
  function normalizeToSet(val, set, aliases) {
    if (!val) return null;
    const normalized = val.trim();
    
    // Direct match in the set
    if (set.includes(normalized)) return normalized;
    
    // Check aliases
    return aliases[normalized] || null;
  }

  // Clean up on unmount
  useEffect(() => {
    return () => {
      // Clear any pending timers when component unmounts
      clearTimeout(pendingDeleteTimer.current);
      clearTimeout(pendingDeleteColTimer.current);
    };
  }, []);

  // Helper to focus an input by section, row, column, and field
  const focusInput = (sectionIdx, rowIdx, colIdx, field = 'value') => {
    // Use parent's focusInput if provided
    if (parentFocusInput) {
      parentFocusInput(sectionIdx, rowIdx, colIdx, field);
      return;
    }
    
    const key = `${sectionIdx}-${rowIdx}-${colIdx}-${field}`;
    const input = inputRefs.current[key];
    if (input) {
      input.focus();
      
      // If it's a text input, position cursor at the end
      if (input.tagName === 'INPUT' || input.tagName === 'TEXTAREA') {
        const length = input.value.length;
        input.setSelectionRange(length, length);
      }
    }
  };

  // Get the value of a cell (by section, row, column, and field)
  const getCellValue = (sectionIdx, rowIdx, colIdx, field = 'value') => {
    const section = sectionData.rowSections[sectionIdx];
    if (!section) return '';
    
    const row = section.rows[rowIdx];
    if (!row) return '';
    
    // Handle row title (first column)
    if (colIdx === 0) {
      return row[field] || '';
    } else {
      // Handle cells (other columns)
      const cellIdx = colIdx - 1;
      return row.cells && row.cells[cellIdx] ? row.cells[cellIdx][field] || '' : '';
    }
  };

  // Get an array of existing values in a column across all rows and sections
  const getColumnValues = (colIdx) => {
    const values = [];
    
    sectionData.rowSections.forEach(section => {
      section.rows.forEach(row => {
        if (colIdx === 0) {
          if (row.value) values.push(row.value);
        } else {
          const cellIdx = colIdx - 1;
          if (row.cells && row.cells[cellIdx] && row.cells[cellIdx].value) {
            values.push(row.cells[cellIdx].value);
          }
        }
      });
    });
    
    return values;
  };

  // Update a cell's value or name
  const updateCell = (sectionIdx, rowIdx, colIdx, field, value) => {
    const updatedSections = [...sectionData.rowSections];
    const section = updatedSections[sectionIdx];
    if (!section) return;
    
    const row = section.rows[rowIdx];
    if (!row) return;
    
    // For row title (colIdx === 0)
    if (colIdx === 0) {
      const updatedRow = { ...row, [field]: value };
      updatedSections[sectionIdx] = {
        ...section,
        rows: [
          ...section.rows.slice(0, rowIdx),
          updatedRow,
          ...section.rows.slice(rowIdx + 1)
        ]
      };
    } else {
      // For cells (colIdx > 0)
      if (!row.cells || colIdx - 1 >= row.cells.length) return;
      
      const updatedCells = [...row.cells];
      updatedCells[colIdx - 1] = {
        ...updatedCells[colIdx - 1],
        [field]: value
      };
      
      const updatedRow = { ...row, cells: updatedCells };
      updatedSections[sectionIdx] = {
        ...section,
        rows: [
          ...section.rows.slice(0, rowIdx),
          updatedRow,
          ...section.rows.slice(rowIdx + 1)
        ]
      };
    }
    
    onDataChange({
      ...sectionData,
      rowSections: updatedSections
    });
  };

  // Insert a new row after the given row
  const insertRow = (sectionIdx, rowIdx) => {
    const section = sectionData.rowSections[sectionIdx];
    if (!section) return;
    
    // Create a new row with empty cells that match the structure of existing rows
    const templateRow = section.rows[0] || { cells: [] };
    
    // Create new row with matching cell structure
    const newRow = {
      id: generateRowId(),
      name: '',
      value: '',
      cells: templateRow.cells.map(cell => ({
        colSectionId: cell.colSectionId || '',
        name: '',
        value: ''
      }))
    };
    
    // Insert the new row and update the data
    const updatedSections = [...sectionData.rowSections];
    updatedSections[sectionIdx] = {
      ...section,
      rows: [
        ...section.rows.slice(0, rowIdx + 1),
        newRow,
        ...section.rows.slice(rowIdx + 1)
      ]
    };
    
    onDataChange({
      ...sectionData,
      rowSections: updatedSections
    });
    
    // Focus the new row after state update
    setTimeout(() => focusInput(sectionIdx, rowIdx + 1, 0, 'value'), 0);
  };

  // Delete a row
  const deleteRow = (sectionIdx, rowIdx) => {
    const section = sectionData.rowSections[sectionIdx];
    if (!section || !section.rows[rowIdx]) return;
    
    // Prevent deleting the last row in the section
    if (section.rows.length <= 1) {
      // Just clear the row contents instead
      const updatedRow = {
        ...section.rows[rowIdx],
        value: '',
        cells: section.rows[rowIdx].cells.map(cell => ({ ...cell, value: '' }))
      };
      
      const updatedSections = [...sectionData.rowSections];
      updatedSections[sectionIdx] = {
        ...section,
        rows: [
          ...section.rows.slice(0, rowIdx),
          updatedRow,
          ...section.rows.slice(rowIdx + 1)
        ]
      };
      
      onDataChange({
        ...sectionData,
        rowSections: updatedSections
      });
      return;
    }
    
    // Remove the row
    const updatedSections = [...sectionData.rowSections];
    updatedSections[sectionIdx] = {
      ...section,
      rows: [
        ...section.rows.slice(0, rowIdx),
        ...section.rows.slice(rowIdx + 1)
      ]
    };
    
    onDataChange({
      ...sectionData,
      rowSections: updatedSections
    });
    
    // Focus the previous row if available, otherwise the next row
    const newRowIdx = rowIdx > 0 ? rowIdx - 1 : 0;
    setTimeout(() => focusInput(sectionIdx, newRowIdx, 0, 'value'), 0);
  };

  // Check if all cells in a column are empty (for column deletion)
  const canDeleteColumn = (colIdx) => {
    // Can't delete row title column
    if (colIdx === 0) return false;
    
    // Check if all cells in this column are empty
    for (const section of sectionData.rowSections) {
      for (const row of section.rows) {
        const cellIdx = colIdx - 1;
        if (row.cells && row.cells[cellIdx] && row.cells[cellIdx].value !== '') {
          return false;
        }
      }
    }
    return true;
  };

  // Delete a column
  const deleteColumn = (colIdx) => {
    // Can't delete row title column
    if (colIdx === 0) return;
    
    // If not all cells are empty, return
    if (!canDeleteColumn(colIdx)) return;
    
    const cellIdx = colIdx - 1;
    const updatedSections = sectionData.rowSections.map(section => {
      const updatedRows = section.rows.map(row => {
        return {
          ...row,
          cells: [
            ...row.cells.slice(0, cellIdx),
            ...row.cells.slice(cellIdx + 1)
          ]
        };
      });
      
      return {
        ...section,
        rows: updatedRows
      };
    });
    
    // Also need to update column sections
    const colSectionId = sectionData.rowSections[0]?.rows[0]?.cells[cellIdx]?.colSectionId;
    const updatedColSections = sectionData.colSections.map(colSection => {
      // Remove this column from the section's cols array
      const updatedCols = colSection.cols.filter(col => {
        if (col.colIndex === colIdx) return false;
        // Adjust colIndex for columns after the deleted one
        if (col.colIndex > colIdx) col.colIndex -= 1;
        return true;
      });
      
      return {
        ...colSection,
        cols: updatedCols
      };
    }).filter(section => section.cols.length > 0); // Remove empty sections
    
    onDataChange({
      rowSections: updatedSections,
      colSections: updatedColSections
    });
  };

  // Handle key navigation and special keys
  const handleKeyDown = (e, sectionIdx, rowIdx, colIdx, field) => {
    // Use parent's handler if available
    if (parentHandleKeyDown) {
      parentHandleKeyDown(e, sectionIdx, rowIdx, colIdx, field);
      return;
    }
    
    const section = sectionData.rowSections[sectionIdx];
    if (!section) return;
    
    // If quickfill is open, handle quickfill navigation keys
    if (quickfillState.open) {
      handleQuickfillKeyDown(e, sectionIdx, rowIdx, colIdx, field);
      return;
    }
    
    // Enter key - Create new row
    if (e.key === 'Enter' && !e.shiftKey && !e.altKey) {
      e.preventDefault();
      insertRow(sectionIdx, rowIdx);
      return;
    }
    
    // Shift+Enter - Move down a row
    if (e.key === 'Enter' && e.shiftKey) {
      e.preventDefault();
      const nextRowIdx = rowIdx + 1;
      if (nextRowIdx < section.rows.length) {
        focusInput(sectionIdx, nextRowIdx, colIdx, field);
      }
      return;
    }
    
    // Tab key - Navigate between fields
    if (e.key === 'Tab') {
      e.preventDefault();
      
      if (!e.shiftKey) {
        // Forward tab
        if (field === 'name') {
          focusInput(sectionIdx, rowIdx, colIdx, 'value');
        } else {
          // Move to next column's name field
          const totalColumns = section.rows[rowIdx]?.cells?.length + 1 || 1;
          if (colIdx < totalColumns - 1) {
            focusInput(sectionIdx, rowIdx, colIdx + 1, 'name');
          } else {
            // If at last column, move to next row's first field
            const nextRowIdx = rowIdx + 1;
            if (nextRowIdx < section.rows.length) {
              focusInput(sectionIdx, nextRowIdx, 0, 'name');
            } else {
              // If at last row, move to next section's first row
              const nextSectionIdx = sectionIdx + 1;
              if (nextSectionIdx < sectionData.rowSections.length) {
                focusInput(nextSectionIdx, 0, 0, 'name');
              }
            }
          }
        }
      } else {
        // Backward tab
        if (field === 'value') {
          focusInput(sectionIdx, rowIdx, colIdx, 'name');
        } else {
          // Move to previous column's value field
          if (colIdx > 0) {
            focusInput(sectionIdx, rowIdx, colIdx - 1, 'value');
          } else {
            // If at first column, move to previous row's last field
            if (rowIdx > 0) {
              const prevRowIdx = rowIdx - 1;
              const prevRow = section.rows[prevRowIdx];
              const lastColIdx = prevRow?.cells?.length || 0;
              focusInput(sectionIdx, prevRowIdx, lastColIdx, 'value');
            } else {
              // If at first row, move to previous section's last row
              if (sectionIdx > 0) {
                const prevSectionIdx = sectionIdx - 1;
                const prevSection = sectionData.rowSections[prevSectionIdx];
                const lastRowIdx = prevSection.rows.length - 1;
                const lastRow = prevSection.rows[lastRowIdx];
                const lastColIdx = lastRow?.cells?.length || 0;
                focusInput(prevSectionIdx, lastRowIdx, lastColIdx, 'value');
              }
            }
          }
        }
      }
      return;
    }
    
    // Arrow key navigation
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
      // Only hijack arrow keys if we're at the edge of the input
      const input = e.target;
      const isAtStart = input.selectionStart === 0;
      const isAtEnd = input.selectionEnd === input.value.length;
      
      if (e.key === 'ArrowUp') {
        if (rowIdx > 0) {
          e.preventDefault();
          focusInput(sectionIdx, rowIdx - 1, colIdx, field);
        } else if (sectionIdx > 0) {
          e.preventDefault();
          // Move to previous section's last row
          const prevSection = sectionData.rowSections[sectionIdx - 1];
          const prevRowIdx = prevSection.rows.length - 1;
          focusInput(sectionIdx - 1, prevRowIdx, colIdx, field);
        }
      } else if (e.key === 'ArrowDown') {
        if (rowIdx < section.rows.length - 1) {
          e.preventDefault();
          focusInput(sectionIdx, rowIdx + 1, colIdx, field);
        } else if (sectionIdx < sectionData.rowSections.length - 1) {
          e.preventDefault();
          // Move to next section's first row
          focusInput(sectionIdx + 1, 0, colIdx, field);
        }
      } else if (e.key === 'ArrowLeft' && isAtStart) {
        // Move to previous field only if at start of current field
        e.preventDefault();
        if (field === 'value') {
          focusInput(sectionIdx, rowIdx, colIdx, 'name');
        } else if (colIdx > 0) {
          focusInput(sectionIdx, rowIdx, colIdx - 1, 'value');
        } else if (rowIdx > 0) {
          // Move to previous row's last column
          const prevRow = section.rows[rowIdx - 1];
          const lastColIdx = prevRow?.cells?.length || 0;
          focusInput(sectionIdx, rowIdx - 1, lastColIdx, 'value');
        }
      } else if (e.key === 'ArrowRight' && isAtEnd) {
        // Move to next field only if at end of current field
        e.preventDefault();
        if (field === 'name') {
          focusInput(sectionIdx, rowIdx, colIdx, 'value');
        } else {
          const totalColumns = section.rows[rowIdx]?.cells?.length + 1 || 1;
          if (colIdx < totalColumns - 1) {
            focusInput(sectionIdx, rowIdx, colIdx + 1, 'name');
          }
        }
      }
      return;
    }
    
    // Delete row with Delete key (when shift is held)
    if (e.key === 'Delete' && e.shiftKey) {
      e.preventDefault();
      
      if (colIdx === 0) {
        // Delete entire row
        if (pendingDeleteRow === `${sectionIdx}-${rowIdx}`) {
          clearTimeout(pendingDeleteTimer.current);
          setPendingDeleteRow(null);
          deleteRow(sectionIdx, rowIdx);
        } else {
          setPendingDeleteRow(`${sectionIdx}-${rowIdx}`);
          
          // Clear the pending delete after a timeout
          clearTimeout(pendingDeleteTimer.current);
          pendingDeleteTimer.current = setTimeout(() => {
            setPendingDeleteRow(null);
          }, 1500);
        }
      } else {
        // Only allow column deletion in first input of column
        if (field !== 'name') return;
        
        if (pendingDeleteCol === `${colIdx}`) {
          clearTimeout(pendingDeleteColTimer.current);
          setPendingDeleteCol(null);
          deleteColumn(colIdx);
        } else {
          setPendingDeleteCol(`${colIdx}`);
          
          // Clear the pending delete after a timeout
          clearTimeout(pendingDeleteColTimer.current);
          pendingDeleteColTimer.current = setTimeout(() => {
            setPendingDeleteCol(null);
          }, 1500);
        }
      }
      return;
    }
    
    // Alt+Space to open quickfill dropdown
    if (e.key === ' ' && e.altKey) {
      e.preventDefault();
      openQuickfill(sectionIdx, rowIdx, colIdx, field);
      return;
    }
    
    // Ctrl+Space to open quickfill dropdown (alternative)
    if (e.key === ' ' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      openQuickfill(sectionIdx, rowIdx, colIdx, field);
      return;
    }
    
    // Up/Down arrow keys with Alt to open quickfill
    if ((e.key === 'ArrowUp' || e.key === 'ArrowDown') && e.altKey) {
      e.preventDefault();
      openQuickfill(sectionIdx, rowIdx, colIdx, field);
      return;
    }
  }; 

  // Compute quickfill options for current cell
  const getQuickfillOptions = (sectionIdx, rowIdx, colIdx, field) => {
    // Use parent's getQuickfillOptions if provided
    if (parentGetQuickfillOptions) {
      return parentGetQuickfillOptions(sectionIdx, rowIdx, colIdx, field);
    }
    
    // Get unique values for this column from other rows
    const existingValues = getColumnValues(colIdx);
    const uniqueValues = Array.from(new Set(existingValues)).filter(Boolean);
    
    // Detect if column matches a known set
    let detectedSets = [];
    
    // Check each known set to see if values match
    for (const setInfo of quickfillKnownSets) {
      // Count matches in the unique values
      const matchCount = uniqueValues.reduce((count, val) => {
        const normalized = normalizeToSet(val, setInfo.set, setInfo.aliases);
        return normalized ? count + 1 : count;
      }, 0);
      
      // If at least one value matches this set and matching ratio is high enough
      if (matchCount > 0 && (matchCount / uniqueValues.length >= 0.3)) {
        detectedSets.push({
          ...setInfo,
          matchCount,
          matchRatio: matchCount / uniqueValues.length
        });
      }
      
      // Also check column name for matches with set aliases
      if (colIdx > 0) {
        // Get column name from the first row
        const firstRow = sectionData.rowSections[0]?.rows[0];
        const columnName = firstRow?.cells[colIdx-1]?.name?.toLowerCase() || '';
        
        // Check if column name contains any aliases for this set
        const nameMatch = setInfo.aliasesForColumn.some(alias => 
          columnName.includes(alias.toLowerCase())
        );
        
        if (nameMatch && !detectedSets.some(s => s.name === setInfo.name)) {
          detectedSets.push({
            ...setInfo,
            matchCount: 0,
            matchRatio: 0.5 // Medium confidence for name matches
          });
        }
      }
    }
    
    // Sort detected sets by match ratio
    detectedSets.sort((a, b) => b.matchRatio - a.matchRatio);
    
    // Sort unique values by frequency
    const valueCounts = existingValues.reduce((counts, val) => {
      counts[val] = (counts[val] || 0) + 1;
      return counts;
    }, {});
    
    const sortedValues = [...uniqueValues].sort((a, b) => valueCounts[b] - valueCounts[a]);
    
    // Build options array
    const options = [];
    
    // Add detected set options first, if any
    if (detectedSets.length > 0) {
      detectedSets.forEach(setInfo => {
        // Add group header
        options.push({
          type: 'group',
          label: setInfo.name
        });
        
        // Add set values
        setInfo.set.forEach(value => {
          options.push({
            type: 'option',
            value,
            frequency: valueCounts[value] || 0,
            group: setInfo.name
          });
        });
        
        // Add separator
        if (sortedValues.length > 0) {
          options.push({
            type: 'group',
            label: 'Existing Values'
          });
        }
      });
      
      // Add existing values not already included in detected sets
      sortedValues.forEach(value => {
        const alreadyIncluded = options.some(opt => opt.type === 'option' && opt.value === value);
        if (!alreadyIncluded) {
          options.push({
            type: 'option',
            value,
            frequency: valueCounts[value],
            group: 'Existing Values'
          });
        }
      });
    }
    
    return options;
  };

  // Helper to close quickfill
  const closeQuickfill = () => {
    // Use parent's closeQuickfill if provided
    if (parentCloseQuickfill) {
      parentCloseQuickfill();
      return;
    }
    
    setQuickfillState({
      sectionIdx: null,
      rowIdx: null,
      colIdx: null,
      field: null,
      open: false,
      selectedIndex: 0
    });
  };

  // Helper to open quickfill for a cell
  const openQuickfill = (sectionIdx, rowIdx, colIdx, field) => {
    // Use parent's openQuickfill if provided
    if (parentOpenQuickfill) {
      parentOpenQuickfill(sectionIdx, rowIdx, colIdx, field);
      return;
    }
    
    // Skip opening for column label fields
    if (field === 'name') return;
    
    // Get quickfill options for this cell
    const options = getQuickfillOptions(sectionIdx, rowIdx, colIdx, field);
    
    // Only open if we have options
    if (options.length > 0) {
      setQuickfillState({
        sectionIdx,
        rowIdx,
        colIdx,
        field,
        open: true,
        selectedIndex: 0,
        options
      });
    }
  };

  // Handle quickfill key events
  const handleQuickfillKeyDown = (e, sectionIdx, rowIdx, colIdx, field) => {
    // Use parent's handler if provided
    if (parentHandleQuickfillKeyDown) {
      parentHandleQuickfillKeyDown(e, sectionIdx, rowIdx, colIdx, field);
      return;
    }
    
    // Only process if the quickfill is open
    if (!quickfillState.open) return;
    
    // Escape to close
    if (e.key === 'Escape') {
      e.preventDefault();
      closeQuickfill();
      return;
    }
    
    // Enter to select
    if (e.key === 'Enter') {
      e.preventDefault();
      const selectedOption = quickfillState.options.filter(opt => opt.type === 'option')[quickfillState.selectedIndex];
      if (selectedOption) {
        updateCell(sectionIdx, rowIdx, colIdx, field, selectedOption.value);
      }
      closeQuickfill();
      return;
    }
    
    // Arrow keys to navigate
    if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
      e.preventDefault();
      
      // Get only option items (not groups)
      const optionItems = quickfillState.options.filter(opt => opt.type === 'option');
      const optionCount = optionItems.length;
      
      if (optionCount === 0) {
        closeQuickfill();
        return;
      }
      
      let newIndex = quickfillState.selectedIndex;
      
      if (e.key === 'ArrowDown') {
        newIndex = (newIndex + 1) % optionCount;
      } else {
        newIndex = (newIndex - 1 + optionCount) % optionCount;
      }
      
      setQuickfillState({
        ...quickfillState,
        selectedIndex: newIndex
      });
    }
  };

  // Handle quickfill option click
  const handleQuickfillOptionClick = (option) => {
    const { sectionIdx, rowIdx, colIdx, field } = quickfillState;
    
    if (option.type === 'option') {
      updateCell(sectionIdx, rowIdx, colIdx, field, option.value);
    }
    
    closeQuickfill();
  };

  // Handle mouse enter for list item to update drag-over state
  const handleMouseEnter = (e, sectionIdx, rowIdx) => {
    if (draggingIndex !== null) {
      setDragOverIndex(`${sectionIdx}-${rowIdx}`);
      
      // Get the position for the insertion line
      const rect = e.currentTarget.getBoundingClientRect();
      setInsertionLineTop(rect.top);
    }
  };

  // Handle drag start
  const handleDragStart = (e, sectionIdx, rowIdx) => {
    setDraggingIndex(`${sectionIdx}-${rowIdx}`);
    e.dataTransfer.setData('text/plain', `${sectionIdx}-${rowIdx}`);
    e.dataTransfer.effectAllowed = 'move';
    
    // Set a custom drag image (optional)
    const dragElement = e.currentTarget;
    const rect = dragElement.getBoundingClientRect();
    e.dataTransfer.setDragImage(dragElement, 10, 10);
  };

  // Handle drag over
  const handleDragOver = (e, sectionIdx, rowIdx) => {
    e.preventDefault();
    if (draggingIndex !== null && draggingIndex !== `${sectionIdx}-${rowIdx}`) {
      setDragOverIndex(`${sectionIdx}-${rowIdx}`);
      
      // Get the position for the insertion line
      const rect = e.currentTarget.getBoundingClientRect();
      const mouseY = e.clientY;
      
      // Determine if we should insert before or after this row
      if (mouseY < rect.top + rect.height / 2) {
        // Insert before
        setInsertionLineTop(rect.top);
      } else {
        // Insert after
        setInsertionLineTop(rect.bottom);
      }
    }
  };

  // Handle drag end
  const handleDragEnd = () => {
    // Reset drag state
    setDraggingIndex(null);
    setDragOverIndex(null);
    setInsertionLineTop(null);
  };

  // Handle drop
  const handleDrop = (e, targetSectionIdx, targetRowIdx) => {
    e.preventDefault();
    
    if (draggingIndex === null) return;
    
    // Parse the dragging indexes
    const [dragSectionIdx, dragRowIdx] = draggingIndex.split('-').map(Number);
    
    // Don't do anything if dropping on the same row
    if (dragSectionIdx === targetSectionIdx && dragRowIdx === targetRowIdx) {
      setDraggingIndex(null);
      setDragOverIndex(null);
      return;
    }
    
    const sourceSectionIdx = dragSectionIdx;
    const sourceRowIdx = dragRowIdx;
    
    // Get the source row
    const sourceSection = sectionData.rowSections[sourceSectionIdx];
    if (!sourceSection) return;
    
    const sourceRow = sourceSection.rows[sourceRowIdx];
    if (!sourceRow) return;
    
    // Create updated sections by removing the source row and adding it to the target position
    const updatedSections = [...sectionData.rowSections];
    
    // Remove the source row
    updatedSections[sourceSectionIdx] = {
      ...sourceSection,
      rows: [
        ...sourceSection.rows.slice(0, sourceRowIdx),
        ...sourceSection.rows.slice(sourceRowIdx + 1)
      ]
    };
    
    // Get the target section/row
    const targetSection = updatedSections[targetSectionIdx];
    if (!targetSection) return;
    
    // Determine insert position based on mouse position (before or after)
    const rect = e.currentTarget.getBoundingClientRect();
    const mouseY = e.clientY;
    let insertIdx = targetRowIdx;
    
    // If mouse is in the bottom half of the target, insert after
    if (mouseY > rect.top + rect.height / 2) {
      insertIdx += 1;
    }
    
    // Insert the source row at the target position
    updatedSections[targetSectionIdx] = {
      ...targetSection,
      rows: [
        ...targetSection.rows.slice(0, insertIdx),
        sourceRow,
        ...targetSection.rows.slice(insertIdx)
      ]
    };
    
    // Update data
    onDataChange({
      ...sectionData,
      rowSections: updatedSections
    });
    
    // Reset drag state
    setDraggingIndex(null);
    setDragOverIndex(null);
    setInsertionLineTop(null);
  };

  // Create an outline-style tree view of the section-based data
  return (
    <div className="outline-mode-v3">
      {insertionLineTop !== null && (
        <div
          className="insertion-line"
          style={{ top: insertionLineTop }}
        />
      )}
      
      {sectionData.rowSections.map((section, sectionIdx) => (
        <div key={section.sectionId} className="row-section">
          <div className="section-label">
            <input
              type="text"
              className="section-name-input"
              value={section.sectionName}
              onChange={(e) => {
                const updatedSections = [...sectionData.rowSections];
                updatedSections[sectionIdx] = {
                  ...section,
                  sectionName: e.target.value
                };
                onDataChange({
                  ...sectionData,
                  rowSections: updatedSections
                });
              }}
              placeholder="Section Name"
            />
          </div>
          
          <ul>
            {section.rows.map((row, rowIdx) => (
              <li
                key={row.id}
                ref={(el) => (liRefs.current[`${sectionIdx}-${rowIdx}`] = el)}
                className={`row-item ${
                  pendingDeleteRow === `${sectionIdx}-${rowIdx}` ? 'pending-delete' : ''
                } ${draggingIndex === `${sectionIdx}-${rowIdx}` ? 'dragging' : ''} ${
                  dragOverIndex === `${sectionIdx}-${rowIdx}` ? 'drag-over' : ''
                }`}
                draggable
                onDragStart={(e) => handleDragStart(e, sectionIdx, rowIdx)}
                onDragOver={(e) => handleDragOver(e, sectionIdx, rowIdx)}
                onDrop={(e) => handleDrop(e, sectionIdx, rowIdx)}
                onDragEnd={handleDragEnd}
              >
                <div className="cell-row">
                  <div
                    className="bullet"
                    draggable
                    onDragStart={(e) => handleDragStart(e, sectionIdx, rowIdx)}
                    title={row.name || 'Row Header'}
                  >
                    •
                  </div>
                  
                  <div className={`row-label ${row.name ? 'has-name' : ''} ${focusedNameField === `${sectionIdx}-${rowIdx}-0` ? 'name-input-focused' : ''}`}>
                    {includeIds && (
                      <span className="row-id">
                        {row.id}
                      </span>
                    )}
                    
                    {includeSections && section.sectionName && (
                      <span className="section-name" title={section.sectionName}>
                        {section.sectionName}
                      </span>
                    )}
                    
                    {includeHeaders && (
                      <input
                        className="label-input"
                        ref={(el) => (inputRefs.current[`${sectionIdx}-${rowIdx}-0-name`] = el)}
                        type="text"
                        placeholder="Header"
                        value={row.name || ''}
                        onChange={(e) => updateCell(sectionIdx, rowIdx, 0, 'name', e.target.value)}
                        onKeyDown={(e) => handleKeyDown(e, sectionIdx, rowIdx, 0, 'name')}
                        onFocus={() => {
                          setFocusedCell({ sectionIdx, rowIdx, colIdx: 0 });
                          setFocusedNameField(`${sectionIdx}-${rowIdx}-0`);
                        }}
                        onBlur={() => {
                          setFocusedNameField(null);
                        }}
                        title={row.name || "Row Header (expand on focus)"}
                      />
                    )}
                    
                    <input
                      className={`value-input ${
                        focusedCell.sectionIdx === sectionIdx &&
                        focusedCell.rowIdx === rowIdx &&
                        focusedCell.colIdx === 0
                          ? 'highlight'
                          : ''
                      }`}
                      ref={(el) => (inputRefs.current[`${sectionIdx}-${rowIdx}-0-value`] = el)}
                      type="text"
                      placeholder="Row Value"
                      value={row.value || ''}
                      onChange={(e) => updateCell(sectionIdx, rowIdx, 0, 'value', e.target.value)}
                      onKeyDown={(e) => handleKeyDown(e, sectionIdx, rowIdx, 0, 'value')}
                      onFocus={() => setFocusedCell({ sectionIdx, rowIdx, colIdx: 0 })}
                    />
                    
                    <span
                      className="delete-row"
                      onClick={() => {
                        if (pendingDeleteRow === `${sectionIdx}-${rowIdx}`) {
                          clearTimeout(pendingDeleteTimer.current);
                          setPendingDeleteRow(null);
                          deleteRow(sectionIdx, rowIdx);
                        } else {
                          setPendingDeleteRow(`${sectionIdx}-${rowIdx}`);
                          
                          // Clear the pending delete after a timeout
                          clearTimeout(pendingDeleteTimer.current);
                          pendingDeleteTimer.current = setTimeout(() => {
                            setPendingDeleteRow(null);
                          }, 1500);
                        }
                      }}
                      title="Click twice to delete row"
                    >
                      ✕
                    </span>
                    
                    {/* Add name badge AFTER the input for proper CSS selection */}
                    {includeHeaders && row.name && (
                      <span 
                        className="name-badge" 
                        title={row.name} 
                        onClick={() => {
                          const input = inputRefs.current[`${sectionIdx}-${rowIdx}-0-name`];
                          if (input) input.focus();
                        }}
                      >
                        {row.name}
                      </span>
                    )}
                  </div>
                </div>
                
                {row.cells && row.cells.length > 0 && (
                  <ul className="sub-bullets">
                    {row.cells.map((cell, cellIdx) => {
                      const colIdx = cellIdx + 1; // Adjust colIdx to account for row title
                      const colSectionName = sectionData.colSections.find(
                        (s) => s.sectionId === cell.colSectionId
                      )?.sectionName || '';
                      
                      return (
                        <li
                          key={`sub-${cellIdx}`}
                          className={`sub-bullet ${
                            pendingDeleteCol === `${colIdx}` ? 'pending-delete' : ''
                          }`}
                        >
                          <div className="sub-bullet-item">
                            {/* Bullet is hidden via CSS */}
                            <div className="bullet">-</div>
                            
                            <div className={`row-label ${cell.name ? 'has-name' : ''} ${focusedNameField === `${sectionIdx}-${rowIdx}-${colIdx}` ? 'name-input-focused' : ''}`}>
                              {/* Single collapsed pill for cell name - expands on hover/focus */}
                              {includeHeaders && (
                                <input
                                  className="label-input"
                                  ref={(el) => (inputRefs.current[`${sectionIdx}-${rowIdx}-${colIdx}-name`] = el)}
                                  type="text"
                                  placeholder="Label"
                                  value={cell.name || ''}
                                  onChange={(e) => updateCell(sectionIdx, rowIdx, colIdx, 'name', e.target.value)}
                                  onKeyDown={(e) => handleKeyDown(e, sectionIdx, rowIdx, colIdx, 'name')}
                                  onFocus={() => {
                                    setFocusedCell({ sectionIdx, rowIdx, colIdx });
                                    setFocusedNameField(`${sectionIdx}-${rowIdx}-${colIdx}`);
                                  }}
                                  onBlur={() => {
                                    setFocusedNameField(null);
                                  }}
                                  title={cell.name || "Cell Header (expand on focus)"}
                                />
                              )}
                              
                              <input
                                className={`value-input ${
                                  focusedCell.sectionIdx === sectionIdx &&
                                  focusedCell.rowIdx === rowIdx &&
                                  focusedCell.colIdx === colIdx
                                    ? 'highlight'
                                    : ''
                                }`}
                                ref={(el) => (inputRefs.current[`${sectionIdx}-${rowIdx}-${colIdx}-value`] = el)}
                                type="text"
                                placeholder="Value"
                                value={cell.value || ''}
                                onChange={(e) => updateCell(sectionIdx, rowIdx, colIdx, 'value', e.target.value)}
                                onKeyDown={(e) => handleKeyDown(e, sectionIdx, rowIdx, colIdx, 'value')}
                                onFocus={() => setFocusedCell({ sectionIdx, rowIdx, colIdx })}
                              />
                              
                              {cellIdx === row.cells.length - 1 && (
                                <span
                                  className="delete-col"
                                  onClick={() => {
                                    if (pendingDeleteCol === `${colIdx}`) {
                                      clearTimeout(pendingDeleteColTimer.current);
                                      setPendingDeleteCol(null);
                                      deleteColumn(colIdx);
                                    } else {
                                      setPendingDeleteCol(`${colIdx}`);
                                      
                                      // Clear the pending delete after a timeout
                                      clearTimeout(pendingDeleteColTimer.current);
                                      pendingDeleteColTimer.current = setTimeout(() => {
                                        setPendingDeleteCol(null);
                                      }, 1500);
                                    }
                                  }}
                                  title="Click twice to delete column"
                                >
                                  ✕
                                </span>
                              )}
                            </div>
                          </div>
                        </li>
                      );
                    })}
                  </ul>
                )}
              </li>
            ))}
          </ul>
        </div>
      ))}
      
      {/* Quickfill dropdown */}
      {quickfillState.open && quickfillState.options && (
        <div
          className="quickfill-dropdown"
          style={{
            position: 'absolute',
            top: inputRefs.current[`${quickfillState.sectionIdx}-${quickfillState.rowIdx}-${quickfillState.colIdx}-${quickfillState.field}`]?.getBoundingClientRect().bottom + 'px',
            left: inputRefs.current[`${quickfillState.sectionIdx}-${quickfillState.rowIdx}-${quickfillState.colIdx}-${quickfillState.field}`]?.getBoundingClientRect().left + 'px',
          }}
        >
          {quickfillState.options.map((option, idx) => {
            if
