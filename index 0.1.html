<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>aboutLiner - Live Outline to Table</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 700px; margin: 2em auto; }
    #editor {
      border: 1px solid #ccc;
      min-height: 200px;
      padding: 10px;
      outline: none;
    }
    ul, li {
      margin: 0;
      padding-left: 1.2em;
      list-style-type: disc;
    }
    table { width: 100%; border-collapse: collapse; margin-top: 1em; }
    th, td { border: 1px solid #aaa; padding: 6px; text-align: left; }
    th { background: #eee; }
    #editor:empty:before {
        content: "• Start typing your outline…";
        color: #888;
        pointer-events: none;
        display: block;
        padding-left: 1.2em;
        }
  </style>
</head>
<body>

<h1>aboutLiner - Live Outline to Table</h1>

<div id="editor" contenteditable="true" spellcheck="false" aria-label="Outline editor"></div>


<div id="tableContainer"></div>

<script>
  const editor = document.getElementById('editor');
  const tableContainer = document.getElementById('tableContainer');

  function placeCaretAtStart(el) {
    el.focus();
    const range = document.createRange();
    range.selectNodeContents(el);
    range.collapse(true);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }

  function syncSubBulletsAcrossTopLevel() {
    const topLevelLis = [...editor.querySelectorAll(':scope > ul > li')];
    let maxSubs = 0;

    topLevelLis.forEach(li => {
      const count = li.querySelectorAll(':scope > ul > li').length;
      if (count > maxSubs) maxSubs = count;
    });

    topLevelLis.forEach(li => {
      let subUl = li.querySelector(':scope > ul');
      if (!subUl && maxSubs > 0) {
        subUl = document.createElement('ul');
        li.appendChild(subUl);
      }
      while (subUl && subUl.children.length < maxSubs) {
        const newLi = document.createElement('li');
        subUl.appendChild(newLi);
      }
    });
  }

  editor.addEventListener('keydown', (e) => {
    if (e.key === 'Tab') {
      e.preventDefault();
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      let li = sel.anchorNode;
      while (li && li.nodeName !== 'LI') {
        li = li.parentNode;
      }
      if (!li) return;

      if (e.shiftKey) {
        const parentUl = li.parentNode;
        const grandParentLi = parentUl.parentNode.closest('li');
        if (!grandParentLi) return;

        parentUl.removeChild(li);
        grandParentLi.parentNode.insertBefore(li, grandParentLi.nextSibling);

        if (parentUl.children.length === 0) {
          parentUl.remove();
        }

      } else {
        const prevLi = li.previousElementSibling;
        if (!prevLi) return;

        let subUl = prevLi.querySelector('ul');
        if (!subUl) {
          subUl = document.createElement('ul');
          prevLi.appendChild(subUl);
        }

        li.parentNode.removeChild(li);
        subUl.appendChild(li);
      }

      syncSubBulletsAcrossTopLevel();
      updateTable();
    }

    if (e.key === 'Enter') {
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      let li = sel.anchorNode;
      while (li && li.nodeName !== 'LI') {
        li = li.parentNode;
      }
      if (!li) return;

      const parentUl = li.parentNode;
      const grandParentLi = parentUl.parentNode.closest('li');

      if (grandParentLi) {
        if (li.textContent.trim() === '' || li.innerHTML === '<br>') {
          e.preventDefault();

          parentUl.removeChild(li);
          grandParentLi.parentNode.insertBefore(li, grandParentLi.nextSibling);

          if (parentUl.children.length === 0) {
            parentUl.remove();
          }

          syncSubBulletsAcrossTopLevel();
          placeCaretAtStart(li);
          updateTable();
          return;
        }
      }
    }
  });

  function parseList(ul) {
    const rows = [];
    const topLevelLis = [...ul.children].filter(el => el.tagName === 'LI');

    let maxCols = 1;
    topLevelLis.forEach(li => {
      const colCount = li.querySelectorAll(':scope > ul > li').length + 1;
      if (colCount > maxCols) maxCols = colCount;
    });

    topLevelLis.forEach(li => {
      const row = [];
      row.push(li.firstChild ? li.firstChild.textContent.trim() : '');

      const subLis = li.querySelectorAll(':scope > ul > li');
      subLis.forEach(subLi => {
        row.push(subLi.textContent.trim());
      });

      while (row.length < maxCols) {
        row.push('');
      }
      rows.push(row);
    });

    return rows;
  }

  function renderTable(rows) {
    if (rows.length === 0) return '<p>No data to show.</p>';

    let html = '<table><thead><tr><th></th>';
    for (let i = 1; i < rows[0].length; i++) {
      html += `<th>Column ${i}</th>`;
    }
    html += '</tr></thead><tbody>';

    rows.forEach((row) => {
      html += `<tr><th>${row[0]}</th>`;
      for (let j = 1; j < row.length; j++) {
        html += `<td>${row[j]}</td>`;
      }
      html += '</tr>';
    });

    html += '</tbody></table>';
    return html;
  }

  function updateTable() {
    const ul = editor.querySelector('ul');
    if (!ul) {
      tableContainer.innerHTML = '<p>No outline found.</p>';
      return;
    }

    const rows = parseList(ul);
    tableContainer.innerHTML = renderTable(rows);
  }

  editor.addEventListener('input', () => {
    syncSubBulletsAcrossTopLevel();
    updateTable();
  });

  editor.addEventListener('keyup', () => {
    syncSubBulletsAcrossTopLevel();
    updateTable();
  });

  updateTable();
  editor.addEventListener('focus', () => {
  if (editor.innerHTML.trim() === '') {
    const ul = document.createElement('ul');
    const li = document.createElement('li');
    ul.appendChild(li);
    editor.appendChild(ul);

    // Move caret inside new li
    const range = document.createRange();
    range.selectNodeContents(li);
    range.collapse(true);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }
});
editor.addEventListener('keydown', (e) => {
  if ((e.key === 'ArrowUp' || e.key === 'ArrowDown') && e.shiftKey) {
    e.preventDefault();
    const sel = window.getSelection();
    if (!sel.rangeCount) return;

    let li = sel.anchorNode;
    while (li && li.nodeName !== 'LI') {
      li = li.parentNode;
    }
    if (!li) return;

    const isPrimary = !li.closest('li li');

    let target;

    if (isPrimary) {
      target = (e.key === 'ArrowUp') ? li.previousElementSibling : li.nextElementSibling;
    } else {
      const subLis = [...li.parentNode.children];
      const index = subLis.indexOf(li);

      const parentLi = li.closest('ul').parentNode.closest('li');
      if (!parentLi) return;

      const siblingParentLi = (e.key === 'ArrowUp') ? parentLi.previousElementSibling : parentLi.nextElementSibling;
      if (!siblingParentLi) return;

      const siblingSubLis = siblingParentLi.querySelectorAll(':scope > ul > li');
      if (siblingSubLis.length === 0) return;

      target = siblingSubLis[Math.min(index, siblingSubLis.length - 1)];
    }

if (target) {
  const range = document.createRange();
  range.selectNodeContents(target);
  range.collapse(false); // cursor at end
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(range);
}

  }
});

</script>

</body>
</html>
